{"ast":null,"code":"// src/services/courseService.ts\n\n// Updated Course interface with correct fields and optional properties\n\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000/api';\n\n// Get courses by program - enhanced with detailed logging and better error handling\nexport const getCoursesByProgram = async programId => {\n  try {\n    const token = localStorage.getItem('token');\n    console.log(`Making API request for program ${programId}`);\n    const response = await fetch(`${API_URL}/courses/program/${programId}`, {\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch courses by program: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n    console.log(`Raw API response for program ${programId}:`, data);\n\n    // Ensure we return an array\n    if (!Array.isArray(data)) {\n      console.warn('API did not return an array, received:', typeof data);\n      return [];\n    }\n\n    // Examine the first item to understand structure\n    if (data.length > 0) {\n      console.log('First course structure:', JSON.stringify(data[0], null, 2));\n    }\n\n    // Normalize the data to ensure consistent structure with semesters properly handled\n    const normalizedCourses = data.map(course => ({\n      course_id: course.course_id,\n      program_id: programId,\n      course_name: course.course_name || '',\n      name: course.name || course.course_name || '',\n      description: course.description || '',\n      department_id: course.department_id || '',\n      duration_minutes: course.duration_minutes || 0,\n      is_core: Boolean(course.is_core),\n      // Ensure semesters is always an array\n      semesters: Array.isArray(course.semesters) ? course.semesters : course.semesters ? [course.semesters] : [],\n      created_at: course.created_at || '',\n      updated_at: course.updated_at || '',\n      // Include professor_course if available\n      professor_course: course.professor_course,\n      // Include semester if available\n      semester: course.semester\n    }));\n    console.log(`Normalized ${normalizedCourses.length} courses for program ${programId}`);\n    console.log('Sample normalized course with semesters:', normalizedCourses.length > 0 ? JSON.stringify(normalizedCourses[0], null, 2) : 'No courses');\n    return normalizedCourses;\n  } catch (error) {\n    console.error(`Error fetching courses for program ${programId}:`, error);\n    return [];\n  }\n};\n\n// Get semesters for a course - new function\nexport const getCourseSemesters = async courseId => {\n  try {\n    const token = localStorage.getItem('token');\n    const response = await fetch(`${API_URL}/courses/${courseId}/semesters`, {\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      console.error(`Failed to fetch semesters for course ${courseId}`);\n      return [];\n    }\n    const data = await response.json();\n    console.log(`Retrieved semesters for course ${courseId}:`, data);\n    return Array.isArray(data) ? data : [];\n  } catch (error) {\n    console.error(`Error fetching semesters for course ${courseId}:`, error);\n    return [];\n  }\n};\n\n// Create a new course\nexport const createCourse = async course => {\n  try {\n    const token = localStorage.getItem('token');\n\n    // Map the frontend course model to match what the backend expects\n    const backendCourse = {\n      course_id: course.course_id,\n      department_id: course.department_id,\n      course_name: course.name || course.course_name,\n      // Handle both name fields\n      duration_minutes: course.duration_minutes,\n      is_core: course.is_core,\n      program_id: course.program_id,\n      // Send single program_id\n      semesters: course.semesters // Include semesters array\n    };\n    console.log('Creating course with data:', backendCourse);\n    const response = await fetch(`${API_URL}/courses`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(backendCourse)\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.message || 'Failed to create course');\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Error creating course:', error);\n    throw error;\n  }\n};\n\n// Update a course\nexport const updateCourse = async (id, course) => {\n  try {\n    const token = localStorage.getItem('token');\n    console.log(`Updating course ${id} with data:`, course);\n\n    // Map the frontend course model to match what the backend expects\n    const backendCourse = {\n      course_name: course.name || course.course_name,\n      // Handle both name fields\n      department_id: course.department_id,\n      duration_minutes: course.duration_minutes,\n      is_core: course.is_core,\n      program_id: course.program_id,\n      // Send single program_id\n      semesters: course.semesters // Include semesters array\n    };\n    const response = await fetch(`${API_URL}/courses/${id}`, {\n      method: 'PUT',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(backendCourse)\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.message || 'Failed to update course');\n    }\n    const responseData = await response.json();\n\n    // Return either the course field if it exists, or the whole response\n    return responseData.course || responseData;\n  } catch (error) {\n    console.error(`Error updating course ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete a course\nexport const deleteCourse = async id => {\n  try {\n    const token = localStorage.getItem('token');\n    console.log(`Attempting to delete course with ID: ${id}`);\n    const response = await fetch(`${API_URL}/courses/${id}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.message || 'Failed to delete course');\n    }\n\n    // Handle 204 No Content or empty responses\n    if (response.status === 204 || response.headers.get('content-length') === '0') {\n      return {\n        success: true,\n        message: 'Course deleted successfully'\n      };\n    }\n    try {\n      const data = await response.json();\n      return {\n        success: true,\n        message: data.message || 'Course deleted successfully'\n      };\n    } catch (parseError) {\n      // If JSON parsing fails but request was successful\n      return {\n        success: true,\n        message: 'Course deleted successfully'\n      };\n    }\n  } catch (error) {\n    console.error(`Error deleting course ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete multiple courses\nexport const deleteCourses = async ids => {\n  try {\n    // For backend compatibility, handle batch deletes as individual deletes if endpoint not available\n    const token = localStorage.getItem('token');\n    console.log(`Attempting to delete multiple courses: ${ids.join(', ')}`);\n\n    // For single course, use the single delete endpoint\n    if (ids.length === 1) {\n      return await deleteCourse(ids[0]);\n    }\n\n    // Try using the batch-delete endpoint first\n    try {\n      const response = await fetch(`${API_URL}/courses/batch-delete`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          ids\n        })\n      });\n      if (response.ok) {\n        const data = await response.json();\n        return {\n          success: true,\n          message: data.message || 'Courses deleted successfully'\n        };\n      }\n\n      // If batch endpoint fails, fall back to individual deletes\n      console.log('Batch delete endpoint failed, falling back to individual deletes');\n    } catch (batchError) {\n      console.log('Error with batch delete, falling back to individual deletes:', batchError);\n    }\n\n    // Individual delete fallback\n    const deletePromises = ids.map(id => deleteCourse(id));\n    const results = await Promise.all(deletePromises);\n\n    // Check if all deletions were successful\n    const allSuccessful = results.every(result => result.success);\n    return {\n      success: allSuccessful,\n      message: allSuccessful ? 'All courses deleted successfully' : 'Some courses could not be deleted'\n    };\n  } catch (error) {\n    console.error(`Error deleting courses:`, error);\n    throw error;\n  }\n};\n\n// Get course by ID - Enhanced version with proper semester handling\nexport const getCourseById = async id => {\n  try {\n    const token = localStorage.getItem('token');\n    console.log(`Fetching course with ID: ${id}`);\n    const response = await fetch(`${API_URL}/courses/${id}`, {\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch course: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n    console.log(`Received course data for ID ${id}:`, data);\n\n    // Transform the data to ensure consistency\n    return {\n      course_id: data.course_id,\n      course_name: data.course_name || '',\n      name: data.name || data.course_name || '',\n      department_id: data.department_id || '',\n      duration_minutes: data.duration_minutes || 0,\n      is_core: Boolean(data.is_core),\n      // Extract program_id from programs array if available\n      program_id: data.program_id || (data.programs && data.programs.length > 0 ? data.programs[0].program_id : ''),\n      // Include other fields as needed\n      programs: data.programs || [],\n      // Ensure semesters are always an array\n      semesters: Array.isArray(data.semesters) ? data.semesters : data.semesters ? [data.semesters] : [],\n      prerequisites: data.prerequisites || [],\n      description: data.description || '',\n      Department: data.Department || null,\n      created_at: data.created_at || '',\n      updated_at: data.updated_at || '',\n      // Include professor_course if available\n      professor_course: data.professor_course,\n      // Include semester if available\n      semester: data.semester\n    };\n  } catch (error) {\n    console.error(`Error fetching course ${id}:`, error);\n    return null;\n  }\n};\n\n// Debug endpoint for program courses\nexport const debugCoursesByProgram = async programId => {\n  try {\n    const token = localStorage.getItem('token');\n    console.log(`Debugging courses for program ${programId}`);\n    const response = await fetch(`${API_URL}/courses/debug/${programId}`, {\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Debug endpoint failed: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n    console.log(`Debug data for program ${programId}:`, data);\n    return data;\n  } catch (error) {\n    console.error(`Error debugging courses for program ${programId}:`, error);\n    // Fixed TypeScript error by checking if error is an instance of Error\n    return {\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n};\nconst courseService = {\n  getAllCourses: async () => {\n    try {\n      const token = localStorage.getItem('token');\n      console.log(\"Attempting to fetch all courses with token:\", token ? \"Token exists\" : \"No token\");\n      const response = await fetch(`${API_URL}/courses`, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      console.log(\"Response status:\", response.status, response.statusText);\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(\"Error response:\", errorText);\n        throw new Error(`Failed to fetch courses: ${response.status} - ${errorText}`);\n      }\n      const data = await response.json();\n      console.log(\"Courses data received:\", data);\n      return data;\n    } catch (error) {\n      console.error('Error fetching courses:', error);\n      // Return empty array but log the detailed error\n      return [];\n    }\n  },\n  getCoursesByProfessor: async professorId => {\n    try {\n      const token = localStorage.getItem('token');\n      const response = await fetch(`${API_URL}/courses/professor/${professorId}`, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error('Failed to fetch courses by professor');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`Error fetching courses for professor ${professorId}:`, error);\n      return [];\n    }\n  },\n  // Including the updated methods in the courseService object\n  getCourseById,\n  getCoursesByProgram,\n  createCourse,\n  updateCourse,\n  deleteCourse,\n  deleteCourses,\n  getCourseSemesters,\n  debugCoursesByProgram\n};\nexport default courseService;","map":{"version":3,"names":["API_URL","process","env","REACT_APP_API_URL","getCoursesByProgram","programId","token","localStorage","getItem","console","log","response","fetch","headers","ok","Error","status","statusText","data","json","Array","isArray","warn","length","JSON","stringify","normalizedCourses","map","course","course_id","program_id","course_name","name","description","department_id","duration_minutes","is_core","Boolean","semesters","created_at","updated_at","professor_course","semester","error","getCourseSemesters","courseId","createCourse","backendCourse","method","body","errorData","message","updateCourse","id","responseData","deleteCourse","get","success","parseError","deleteCourses","ids","join","batchError","deletePromises","results","Promise","all","allSuccessful","every","result","getCourseById","programs","prerequisites","Department","debugCoursesByProgram","courseService","getAllCourses","errorText","text","getCoursesByProfessor","professorId"],"sources":["C:/Users/shash/Documents/Master's Colleges/UNIVERSITY OF DELAWARE/COURSES/Project/university-scheduler/frontend/src/services/courseService.ts"],"sourcesContent":["// src/services/courseService.ts\r\n\r\n// Updated Course interface with correct fields and optional properties\r\nexport interface Course {\r\n  course_id: string;\r\n  program_id?: string;  // Make optional to handle different backend responses\r\n  department_id: string; // Required field\r\n  name?: string; \r\n  course_name: string; // For backend compatibility\r\n  description?: string;\r\n  duration_minutes: number;\r\n  is_core: boolean;\r\n  semesters?: string[];  // Optional array of semesters\r\n  semester?: string;     // Optional single semester\r\n  created_at: string;\r\n  updated_at: string;\r\n  program?: any;\r\n  programs?: any[];      // For courses with multiple programs\r\n  prerequisites?: any[];\r\n  Department?: any;      // For Department association\r\n  professor_course?: {   // Add professor_course property\r\n    semester: string;\r\n  };\r\n}\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000/api';\r\n\r\n// Get courses by program - enhanced with detailed logging and better error handling\r\nexport const getCoursesByProgram = async (programId: string): Promise<Course[]> => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    console.log(`Making API request for program ${programId}`);\r\n    \r\n    const response = await fetch(`${API_URL}/courses/program/${programId}`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch courses by program: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    \r\n\r\n    const data = await response.json();\r\n    console.log(`Raw API response for program ${programId}:`, data);\r\n    \r\n    // Ensure we return an array\r\n    if (!Array.isArray(data)) {\r\n      console.warn('API did not return an array, received:', typeof data);\r\n      return [];\r\n    }\r\n    \r\n    // Examine the first item to understand structure\r\n    if (data.length > 0) {\r\n      console.log('First course structure:', JSON.stringify(data[0], null, 2));\r\n    }\r\n    \r\n    // Normalize the data to ensure consistent structure with semesters properly handled\r\n    const normalizedCourses = data.map(course => ({\r\n      course_id: course.course_id,\r\n      program_id: programId,\r\n      course_name: course.course_name || '',\r\n      name: course.name || course.course_name || '',\r\n      description: course.description || '',\r\n      department_id: course.department_id || '',\r\n      duration_minutes: course.duration_minutes || 0,\r\n      is_core: Boolean(course.is_core),\r\n      // Ensure semesters is always an array\r\n      semesters: Array.isArray(course.semesters) ? course.semesters : \r\n               (course.semesters ? [course.semesters] : []),\r\n      created_at: course.created_at || '',\r\n      updated_at: course.updated_at || '',\r\n      // Include professor_course if available\r\n      professor_course: course.professor_course,\r\n      // Include semester if available\r\n      semester: course.semester\r\n    }));\r\n    \r\n    console.log(`Normalized ${normalizedCourses.length} courses for program ${programId}`);\r\n    console.log('Sample normalized course with semesters:', \r\n      normalizedCourses.length > 0 ? JSON.stringify(normalizedCourses[0], null, 2) : 'No courses');\r\n    \r\n    return normalizedCourses;\r\n  } catch (error) {\r\n    console.error(`Error fetching courses for program ${programId}:`, error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Get semesters for a course - new function\r\nexport const getCourseSemesters = async (courseId: string): Promise<string[]> => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    \r\n    const response = await fetch(`${API_URL}/courses/${courseId}/semesters`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      console.error(`Failed to fetch semesters for course ${courseId}`);\r\n      return [];\r\n    }\r\n    \r\n    const data = await response.json();\r\n    console.log(`Retrieved semesters for course ${courseId}:`, data);\r\n    return Array.isArray(data) ? data : [];\r\n  } catch (error) {\r\n    console.error(`Error fetching semesters for course ${courseId}:`, error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Create a new course\r\nexport const createCourse = async (course: Partial<Course>): Promise<Course> => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    \r\n    // Map the frontend course model to match what the backend expects\r\n    const backendCourse = {\r\n      course_id: course.course_id,\r\n      department_id: course.department_id,\r\n      course_name: course.name || course.course_name, // Handle both name fields\r\n      duration_minutes: course.duration_minutes,\r\n      is_core: course.is_core,\r\n      program_id: course.program_id, // Send single program_id\r\n      semesters: course.semesters // Include semesters array\r\n    };\r\n    \r\n    console.log('Creating course with data:', backendCourse);\r\n    \r\n    const response = await fetch(`${API_URL}/courses`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify(backendCourse)\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorData = await response.json();\r\n      throw new Error(errorData.message || 'Failed to create course');\r\n    }\r\n\r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error('Error creating course:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Update a course\r\nexport const updateCourse = async (id: string, course: Partial<Course>): Promise<Course> => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    \r\n    console.log(`Updating course ${id} with data:`, course);\r\n    \r\n    // Map the frontend course model to match what the backend expects\r\n    const backendCourse = {\r\n      course_name: course.name || course.course_name, // Handle both name fields\r\n      department_id: course.department_id,\r\n      duration_minutes: course.duration_minutes,\r\n      is_core: course.is_core,\r\n      program_id: course.program_id, // Send single program_id\r\n      semesters: course.semesters // Include semesters array\r\n    };\r\n    \r\n    const response = await fetch(`${API_URL}/courses/${id}`, {\r\n      method: 'PUT',\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify(backendCourse)\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorData = await response.json();\r\n      throw new Error(errorData.message || 'Failed to update course');\r\n    }\r\n\r\n    const responseData = await response.json();\r\n    \r\n    // Return either the course field if it exists, or the whole response\r\n    return responseData.course || responseData;\r\n  } catch (error) {\r\n    console.error(`Error updating course ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Delete a course\r\nexport const deleteCourse = async (id: string): Promise<{ success: boolean; message: string }> => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    console.log(`Attempting to delete course with ID: ${id}`);\r\n    \r\n    const response = await fetch(`${API_URL}/courses/${id}`, {\r\n      method: 'DELETE',\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorData = await response.json();\r\n      throw new Error(errorData.message || 'Failed to delete course');\r\n    }\r\n\r\n    // Handle 204 No Content or empty responses\r\n    if (response.status === 204 || response.headers.get('content-length') === '0') {\r\n      return {\r\n        success: true,\r\n        message: 'Course deleted successfully'\r\n      };\r\n    }\r\n\r\n    try {\r\n      const data = await response.json();\r\n      return {\r\n        success: true,\r\n        message: data.message || 'Course deleted successfully'\r\n      };\r\n    } catch (parseError) {\r\n      // If JSON parsing fails but request was successful\r\n      return {\r\n        success: true,\r\n        message: 'Course deleted successfully'\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error deleting course ${id}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Delete multiple courses\r\nexport const deleteCourses = async (ids: string[]): Promise<{ success: boolean; message: string }> => {\r\n  try {\r\n    // For backend compatibility, handle batch deletes as individual deletes if endpoint not available\r\n    const token = localStorage.getItem('token');\r\n    console.log(`Attempting to delete multiple courses: ${ids.join(', ')}`);\r\n    \r\n    // For single course, use the single delete endpoint\r\n    if (ids.length === 1) {\r\n      return await deleteCourse(ids[0]);\r\n    }\r\n    \r\n    // Try using the batch-delete endpoint first\r\n    try {\r\n      const response = await fetch(`${API_URL}/courses/batch-delete`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({ ids })\r\n      });\r\n      \r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        return {\r\n          success: true,\r\n          message: data.message || 'Courses deleted successfully'\r\n        };\r\n      }\r\n      \r\n      // If batch endpoint fails, fall back to individual deletes\r\n      console.log('Batch delete endpoint failed, falling back to individual deletes');\r\n    } catch (batchError) {\r\n      console.log('Error with batch delete, falling back to individual deletes:', batchError);\r\n    }\r\n    \r\n    // Individual delete fallback\r\n    const deletePromises = ids.map(id => deleteCourse(id));\r\n    const results = await Promise.all(deletePromises);\r\n    \r\n    // Check if all deletions were successful\r\n    const allSuccessful = results.every(result => result.success);\r\n    \r\n    return {\r\n      success: allSuccessful,\r\n      message: allSuccessful \r\n        ? 'All courses deleted successfully' \r\n        : 'Some courses could not be deleted'\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error deleting courses:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Get course by ID - Enhanced version with proper semester handling\r\nexport const getCourseById = async (id: string): Promise<Course | null> => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    console.log(`Fetching course with ID: ${id}`);\r\n    \r\n    const response = await fetch(`${API_URL}/courses/${id}`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch course: ${response.status} ${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    console.log(`Received course data for ID ${id}:`, data);\r\n    \r\n    // Transform the data to ensure consistency\r\n    return {\r\n      course_id: data.course_id,\r\n      course_name: data.course_name || '',\r\n      name: data.name || data.course_name || '',\r\n      department_id: data.department_id || '',\r\n      duration_minutes: data.duration_minutes || 0,\r\n      is_core: Boolean(data.is_core),\r\n      // Extract program_id from programs array if available\r\n      program_id: data.program_id || (data.programs && data.programs.length > 0 ? data.programs[0].program_id : ''),\r\n      // Include other fields as needed\r\n      programs: data.programs || [],\r\n      // Ensure semesters are always an array\r\n      semesters: Array.isArray(data.semesters) ? data.semesters : \r\n               (data.semesters ? [data.semesters] : []),\r\n      prerequisites: data.prerequisites || [],\r\n      description: data.description || '',\r\n      Department: data.Department || null,\r\n      created_at: data.created_at || '',\r\n      updated_at: data.updated_at || '',\r\n      // Include professor_course if available\r\n      professor_course: data.professor_course,\r\n      // Include semester if available\r\n      semester: data.semester\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error fetching course ${id}:`, error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Debug endpoint for program courses\r\nexport const debugCoursesByProgram = async (programId: string): Promise<any> => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    console.log(`Debugging courses for program ${programId}`);\r\n    \r\n    const response = await fetch(`${API_URL}/courses/debug/${programId}`, {\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Debug endpoint failed: ${response.status} ${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    console.log(`Debug data for program ${programId}:`, data);\r\n    return data;\r\n  } catch (error) {\r\n    console.error(`Error debugging courses for program ${programId}:`, error);\r\n    // Fixed TypeScript error by checking if error is an instance of Error\r\n    return { \r\n      error: error instanceof Error ? error.message : 'Unknown error' \r\n    };\r\n  }\r\n};\r\n\r\nconst courseService = {\r\n  getAllCourses: async (): Promise<Course[]> => {\r\n    try {\r\n      const token = localStorage.getItem('token');\r\n      console.log(\"Attempting to fetch all courses with token:\", token ? \"Token exists\" : \"No token\");\r\n      \r\n      const response = await fetch(`${API_URL}/courses`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      console.log(\"Response status:\", response.status, response.statusText);\r\n      \r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        console.error(\"Error response:\", errorText);\r\n        throw new Error(`Failed to fetch courses: ${response.status} - ${errorText}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n      console.log(\"Courses data received:\", data);\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching courses:', error);\r\n      // Return empty array but log the detailed error\r\n      return [];\r\n    }\r\n  },\r\n  \r\n  \r\n\r\n  getCoursesByProfessor: async (professorId: string): Promise<Course[]> => {\r\n    try {\r\n      const token = localStorage.getItem('token');\r\n      const response = await fetch(`${API_URL}/courses/professor/${professorId}`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch courses by professor');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error(`Error fetching courses for professor ${professorId}:`, error);\r\n      return [];\r\n    }\r\n  },\r\n  \r\n  // Including the updated methods in the courseService object\r\n  getCourseById,\r\n  getCoursesByProgram,\r\n  createCourse,\r\n  updateCourse,\r\n  deleteCourse,\r\n  deleteCourses,\r\n  getCourseSemesters,\r\n  debugCoursesByProgram\r\n};\r\n\r\nexport default courseService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}